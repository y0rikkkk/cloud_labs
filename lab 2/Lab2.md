**Лаба 2**  
**Обычный уровень сложности**

*Цель:*

1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов  
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены  
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат  
4. В Readme описать 2 плохих практики по работе с контейнерами. \! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.  
     
   

*Выполнение работы:*  
Для начала был установлен докер, так как раньше с ним приходилось сталкиваться, но это было достаточно давно, также потребовалось освежить свои знания о том, как он работает. В качестве приложения был создан сайт, работающий на flask. Далее приступим к написанию докерфайлов.  
   
Плохой докерфайл получился следующим:  
*FROM python:latest*

*WORKDIR /app*  
   
*RUN apt-get update \-y*  
*RUN apt-get install \-y python3-pip python3-dev build-essential*  
*RUN pip3 install flask*  
   
*COPY requirements.txt /app*  
   
*RUN pip3 install \--no-cache-dir \-r requirements.txt*  
   
*COPY . /app*  
   
*EXPOSE 8081*  
   
*CMD \["python3", "app.py"\]*  
   
При помощи его был собран и запущен контейнер, и все заработало, даже с учетом “bad practice”.  
   
Использованные плохие практики:  
   
**1\)	В плохом докерфайле была использована конструкция**  
***FROM python:latest***  
Использование такой конструкции не является хорошей практикой, так как базовые образы достаточно часто обновляются, что может впоследствии привести к конфликту версий. При сборке контейнера лучше использовать конкретную версию образа, например как в хорошем dockerfile был использован  
   
*FROM python:3.9*  
   
**2\)	USER**  
   
В плохом докерфайле не указан пользователь, поэттому все процессы выполняются с root, то есть каждый пользователь может получить доступ. В случае серьезных контейнеров могут возникнуть серьезные проблемы с безопасносью, поэтому в хорошем докерфайле был добавлен пользователь app\_user  
   
**3\)	Несколько run**  
каждый run создает новый слой при сборке образа, что явно делает ее менее эффективной. В хорошем докерфайле конструкция  
   
*RUN apt-get update \-y*  
*RUN apt-get install \-y python3-pip python3-dev build-essential*  
*RUN pip3 install flask*  
   
Была заменена на:  
   
*RUN apt-get update \-y &&  \\*  
	*pip install \--no-cache-dir flask && \\*  
	*useradd app\_user && \\*  
	*apt-get autoremove \-y && \\*  
	*apt-get clean*  
   
Также сюда посравнении с baddocker была добавлена очистка кеша, что также оптимизирует сборку.  
   
Таким образом хороший Dockerfile получился следующим  
   
*FROM python:3.9*  
   
*WORKDIR /app*  
   
*\# Установка необходимых системных зависимостей и Python библиотек*  
*RUN apt-get update \-y &&  \\*  
	*pip install \--no-cache-dir flask && \\*  
	*useradd app\_user && \\*  
	*apt-get autoremove \-y && \\*  
	*apt-get clean*  
   
*COPY requirements.txt /app*  
   
*RUN pip install \--no-cache-dir \-r requirements.txt*  
   
*COPY . /app*  
   
*USER app\_user*  
   
*EXPOSE 8082*  
   
*CMD \["python", "app.py"\]*  
   
   
Две плохие практики по работе с контейнерами:

### **1\)   Учетные данные и конфиденциальность**

В докерфайлы не стоит помещать чувствительные либо же учетные данные. Даже если эти файлы далее удаляются, к ним можно получить доступ на предыдущих слоях, что может нести явную угрозу безопасности данных.  
   
**2\)	Неограниченное использование памяти.**  
Без заданного ограничения контейнеры могут использовать всевозможные ресурсы, что не есть хорошо. Лучше добавлять ограничение по использованию памяти, например:  
   
*docker run \--memory="512m" \--memory-swap="1g" your\_image\_name*  
 

