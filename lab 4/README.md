# Лаба 4 юхууу

## Задание: 
1. Написать “плохой” CI/CD файл, который работает, но в нем есть не менее пяти “bad practices” по написанию CI/CD
2. Написать “хороший” CI/CD, в котором эти плохие практики исправлены
3. В Readme описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат

   ## Дисклеймер:
Работа велась в отдельном [репо](https://github.com/DariaLaricheva/cloud-lab4). Во время работы над данной лабой я больше намучилась с косяками в тестах, простеньком коде проекта и зависимостях… Ужос…. Но зато теперь, работая hr-ом, я могу похвастаться девопсам на работе, что я тоже корявенький, но девопс хех.

1. Написать “плохой” CI/CD файл, который работает, но в нем есть не менее пяти “bad practices” по написанию CI/CD

В Общем, достаточно интересно получилось, но плохой файл выглядит вот так:


```yaml
name: CI/CD with bad practise


# запуск на всех ветках
on:
 push:
   branches:
     - '*'
# все шаги в одной джобе, нет деления на билд тест деплой
jobs:
 test:
   runs-on: ubuntu-latest


   steps:
     - name: Checkout code
       uses: actions/checkout@v2


     # установка зависимостей без создания виртуального окружения
     - name: Install dependencies
       run: |
         pip install -r requirements.txt  # Установка в глобальное окружение может вызвать конфликты


     # пропуск тестов
     - name: Skip tests
       run: echo "Skipping tests"


     # тесты и так пропустили, так еще и деплоим без проверки пройденности, во неадекваты....
     - name: Build and deploy
       run: |
         echo "Building the project..."  # Отсутствие проверки успешности предыдущих шагов

```

Впринципе, в коде и так помечено что и где не так, но пройдемся по порядочку:
### 1. Запуск на всех ветках
   Запуск CI/CD на всех ветках может привести к ненужным действиям и ресурсным затратам. Например, если разработчик создает множество временных веток, каждый пуш будет вызывать запуск CI/CD, что может замедлить работу и привести к увеличению затрат на ресурсы. Короче не очень хорошо
### 2. Все этапы смешаны в одной джобе
   Не очень хорошо, затрудняет отладку, в случае обвала может быть затруднен поиск ошибки и где вообще что не так пошло, ну и читается не так приятно
### 3. Установка зависимостей без создания виртуального окружения
   Этот шаг может привести к конфликту версий и проблемам с совместимостью
### 4. Пропуск тестов
   Здесь мы просто стали гениями и решили, что тесты нам не нужны, таким образом непротестированный код пойдет дальше, а вдруг там ошибочки....
### 5. Деплой без тестов
   Деплой без предварительной проверки успешности выполнения тестов является крайне рискованным. Это может привести к развертыванию неработоспособного кода
### 6. Не указана версия python
   Из-за этого поведение кода может отличаться, а также многие библиотеки не смогут подгрузиться, т.к. требуют актуальную версию Python.

Написали плохой пайплайн, но все же он работает, сейчас будем фиксить)))

2.  Написать “хороший” CI/CD, в котором эти плохие практики исправлены
Собственно, не уверена, что оооочень хороший, но исправленный пайплайн получился вот такой:

```yaml

name: CI/CD with good practise

# тут определяем нужные веточки
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
# поделили джобы, чтоб потом не запутаться
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      # Указываем конкретную версию Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      # Создаем виртуальное окружение и устанавливаем зависимости
      - name: Install dependencies
        run: |
            python -m venv venv
            source venv/bin/activate
            pip install -r requirements.txt

      # Кэшируем зависимости для ускорения установки
      - name: Cache dependencies
        uses: actions/cache@v2
        with:
          path: venv/lib/python*/site-packages
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

  test:
    runs-on: ubuntu-latest
    needs: build  # Зависимость от задания build

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      # Указываем конкретную версию Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m venv venv
          source venv/bin/activate
          pip install -r requirements.txt

      - name: Run tests
        run: |
            source venv/bin/activate  # Активируем виртуальное окружение перед запуском тестов
            pytest  || { echo 'Tests failed'; exit 1; }
  

  deploy:
    runs-on: ubuntu-latest
    needs: test  # Зависимость от задания test (ура теперь адекваты, без пройденных тестов не деплоим)

    steps:
      - name: Checkout code
        uses: actions/checkout@v2


      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.11'

      # Проверяем успешность выполнения предыдущих шагов перед развертыванием
      - name: Build and deploy
        if: success()
        run: |
          python -m venv venv
          source venv/bin/activate  # Активируем виртуальное окружение перед сборкой
          echo "Building the project..."
```
А теперь пробежимся по изменениям:
### 1. Теперь код запускается на основной ветке
Благодаря этому не будут расходоваться лишние ресурсы
### 2. Джобы поделены на билд, тест и деплой
Теперь можно просматривать результаты каждой джобы отдельно, легче понимать что где валится и легче разбираться в коде. Кроме того между джобами были установлены зависимости, теперь без пройденного предыдущего этапа не будет выполнен переход к следующему
### 3. Указана конкретная версия python
Теперь среда является более стабильной
### 4. Зависимости устанавливаются в виртуальное окружение
Создание виртуального окружения для установки зависимостей — это хорошая практика, так как она изолирует зависимости проекта от системы, что снижает вероятность конфликтов. Также было добавлено кэширование зависимостей для ускорения установки.
### 5. Зависимость деплоя от задания test
Теперь код, не прошедший тест, не будет задеплоен, неработающий код не пройдет дальше
## Заключение
Очень интересная лабораторная, было достаточно тяжко, но классно. В общем, хорошие практики в пайплайне помогут сделать его более надежным и не пропускать в деплой неправильный код!
